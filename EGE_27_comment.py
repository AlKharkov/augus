with open('27_B.txt') as inlet:
    n = int(inlet.readline())  # считывает N
    distance = [0]  # первые числа из каждой пары - расстояние от нулевой точки до пункта
    counts = [0]  # количество коробок, требуемое для транспортировки в каждый пункт
    pref = [0]  # префиксный массив - хранится СУММА коробок для всех предыдущих пунктов
    post = [0]  # постфиксный массив - хранится СУММА коробок для всех следующих пунктов

    for i in range(n):  # заполняем первые 3 массива - distance, counts, pref
        a, b = map(int, inlet.readline().rstrip().split())  # считываем строку и преобразуем её в 2 числа
        distance.append(a)
        counts.append(b // 36 + (b % 36 != 0))
        pref.append(pref[-1] + counts[-1])

    for i in range(n, 0, -1):  # заполняем массив post
        post.append(post[-1] + counts[i])
    post.reverse()  # разворачиваем массив - post[0], post[-1] = post[-1], post[0] ...

    left, right = 0, 0  # затраты на доставку слева и справа соответственно
    for i in range(n + 1):  # пусть изначально мы стоим вначале координат, в точке 0
        right += distance[i] * counts[i]

    # Метод решения заключается в том, чтобы идти по массиву и считать затраты на доставу слева и справа отдельно
    # Произведение расстояния на количество коробок можно представить, как площадь прямоугольника
    # При сдвиге в соседний справа пункт left увеличится на: ...
    # ..."разница расстояний" * "сумма количеств коробок пунктов слева"
    # Аналогично с изменением right. Получается мы можем быстро считать для каждого пнукта(если идти подряд) результат

    result = right  # минимальные затраты на доставку
    for i in range(1, n + 1):
        left += pref[i - 1] * (distance[i] - distance[i - 1])
        right -= post[i - 1] * (distance[i] - distance[i - 1])
        result = min(result, left + right)  # ищем минимально возможную сумму
    print(result)
